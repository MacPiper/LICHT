

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Funktionsbloecke' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK LICHT
VAR_INPUT
	TASTER : BOOL;
	RETRIGGER_ON_TIME : BOOL;
	EIN : BOOL;
	AUS_SOFORT : BOOL;
	AUS_MIT_ANGEKUENDIGUNG: BOOL;
	INHIBIT_AUTO_OFF: BOOL;
END_VAR
VAR_INPUT CONSTANT
	ON_TIME:TIME := t#30m;
	ON_TIME_DAUER:TIME := t#12h;
	AFTERRUN_TIME:TIME := t#15s;
END_VAR
VAR_OUTPUT
	POWER:BOOL;
	POWER_NO_BLINK:BOOL;
END_VAR
VAR
	zustand_en:lichtZustand_ten :=LICHT_ZUSTAND_AUS;
	tasterPosEdge : R_TRIG;
	tasterLongPress : TON;
	retriggerOnTimeEdge : R_TRIG;
 	einPosEdge : R_TRIG;
	einLongPress : TON;
	ausSofortEdge : R_TRIG;
	ausMitAnkuendigungEdge : R_TRIG;
	tonTimer : TON;
	blinkPulse : CLK_PULSE;
	ausschaltPhase: BYTE := 0;
       afterrunTimer : TON;
END_VAR
(* @END_DECLARATION := '0' *)
tasterPosEdge(CLK := TASTER );
tasterLongPress(IN := TASTER, PT := t#500ms );
retriggerOnTimeEdge(CLK := RETRIGGER_ON_TIME);
einPosEdge(CLK := EIN );
einLongPress(IN := EIN, PT := t#500ms );
ausSofortEdge(CLK := AUS_SOFORT );
ausMitAnkuendigungEdge(CLK := AUS_MIT_ANGEKUENDIGUNG );
afterrunTimer(IN := (LICHT_ZUSTAND_AUSSCHALT_WARNUNG = zustand_en), PT := AFTERRUN_TIME );


IF (TRUE = retriggerOnTimeEdge.Q) THEN
	tonTimer(IN := 0, PT := ON_TIME );
ELSIF (LICHT_ZUSTAND_EIN_ZEITBEGRENZT = zustand_en) THEN
	 tonTimer(IN := 1, PT := ON_TIME );
ELSE
	tonTimer(IN := POWER, PT := ON_TIME_DAUER );
END_IF

CASE (zustand_en) OF
	LICHT_ZUSTAND_AUS:
		IF( (TRUE = tasterPosEdge.Q) OR (TRUE = einPosEdge.Q) ) THEN
			(*  Switch on via positive edge on input TASTER or EIN *)
			zustand_en := LICHT_ZUSTAND_EIN_ZEITBEGRENZT;
		END_IF
		POWER := FALSE;
		POWER_NO_BLINK := FALSE;

	LICHT_ZUSTAND_EIN_ZEITBEGRENZT:
		IF ( (TRUE = tasterPosEdge.Q) OR (TRUE = ausSofortEdge.Q) ) THEN
			zustand_en := LICHT_ZUSTAND_AUS;
		ELSIF ((TRUE = tasterLongPress.Q)  OR (TRUE = einLongPress.Q) OR (t#0s = ON_TIME)) THEN
			zustand_en := LICHT_ZUSTAND_EIN_DAUER;
		ELSIF (  ( (TRUE = tonTimer.Q) AND (FALSE = INHIBIT_AUTO_OFF ) )OR (TRUE = ausMitAnkuendigungEdge.Q)  ) THEN
			zustand_en := LICHT_ZUSTAND_AUSSCHALT_WARNUNG;
		END_IF
		POWER := TRUE;
		POWER_NO_BLINK := TRUE;

	LICHT_ZUSTAND_EIN_DAUER:
		IF( (TRUE = tasterPosEdge.Q) OR (TRUE = ausSofortEdge.Q) ) THEN
			zustand_en := LICHT_ZUSTAND_AUS;
		ELSIF (  ( (TRUE = tonTimer.Q) AND (FALSE = INHIBIT_AUTO_OFF ) )OR (TRUE = ausMitAnkuendigungEdge.Q)  ) THEN
			zustand_en := LICHT_ZUSTAND_AUSSCHALT_WARNUNG;
		END_IF
		POWER := TRUE;
		POWER_NO_BLINK := TRUE;

	LICHT_ZUSTAND_AUSSCHALT_WARNUNG:
		blinkPulse(PT := t#250ms,N :=10, rst:=0);
		(* Leaving afterrun with EIN pulse is probably a bad idea as it is not visible but what's the option? *)
		IF ((TRUE = tasterPosEdge.Q) OR (TRUE = einPosEdge.Q) OR (TRUE = retriggerOnTimeEdge.Q)) THEN
			tonTimer(IN := 0, PT := ON_TIME );
			blinkPulse(PT := t#250ms,N :=10, rst:=1);
			zustand_en := LICHT_ZUSTAND_EIN_ZEITBEGRENZT;
			POWER := TRUE;
			POWER_NO_BLINK := TRUE;
		ELSIF ( ( TRUE = afterrunTimer.Q ) OR (TRUE =ausSofortEdge.Q) )THEN
			blinkPulse(PT := t#250ms,N :=10, rst:=1);
			zustand_en := LICHT_ZUSTAND_AUS;
			POWER := FALSE;
			POWER_NO_BLINK := FALSE;
		ELSE
			POWER := ( ((blinkPulse.cnt+7) MOD 8) > 0 );
			POWER_NO_BLINK := TRUE;
		END_IF

END_CASE;

(* Author: MacPiper
Changelog:
24.10.13 ver 1.1. Allow retrigger of on-time in afterrun state
*)
END_FUNCTION_BLOCK
